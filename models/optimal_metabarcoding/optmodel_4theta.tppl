/*
 * File: optmodel_4theta.tppl
 * Description: Probabilistic model taken from optimal metabarcoding, draft 2023-09-13
 * Compilation:
 *   tpplc models/optmetabar/optmodel_4theta.tppl -m 'smc-bpf' --resample align --output optmodel_4theta
 * Execution with 100000 particles and 100 sweeps (homogenate data H.json or lysate data L.json): 
 * ./optmodel_4theta models/data/H_real.json 100000 100 > output/H_4theta.json
 */

/*
 * Model function
 * Data:
 *   Homogenate data in H.json or lysate data in L.json: 
 * Priors: 
 *   From optimal metabarcoding paper, Iwaszkiewicz-Eggebrecht et al., 2023
 * Posterior:
 *   returning k at the moment
 */
model function myModel(dataset: Real[][]) : Real  {
  assume k ~ Gamma(1.0, 10.0);
  assume logTheta1 ~ Gaussian(0.0, 2.0); 
  let theta1 = exp(logTheta1);
  assume logTheta2 ~ Gaussian(0.0, 2.0); 
  let theta2 = exp(logTheta2);
  assume logTheta3 ~ Gaussian(0.0, 2.0); 
  let theta3 = exp(logTheta3);
  assume logTheta4 ~ Gaussian(0.0, 2.0); 
  let theta4 = exp(logTheta4);
  
  assume tau ~ Gamma(3.0, (1.0/27.0));
  let sigma = sqrt(1.0 / tau); //sigma2 sampled from InverseGamma
  assume mu ~ Gaussian(6.5, sigma); 

  let nsamples = length(dataset); // nsamples is total number of samples, with index j
  for j in 1 to nsamples { 
    assume logC ~ Gaussian(mu, sigma); 
    let c = exp(logC);
    if dataset[j][1] > 0.0 {
      observe dataset[j][1] ~ Gamma(k, c*theta1);
    }
    if dataset[j][2] > 0.0 {
      observe dataset[j][2] ~ Gamma(k, c*theta2);
    }
    if dataset[j][3] > 0.0 {
      observe dataset[j][3] ~ Gamma(k, c*theta3);
    }
    if dataset[j][4] > 0.0 {
      observe dataset[j][4] ~ Gamma(k, c*theta4);
    }
  }
  return(k); 
}