/*
 * File: optmodel15_Pred.tppl
 * Description: Probabilistic model taken from optimal metabarcoding adjusted to 15samples
 * Compilation:
 *  tpplc models/metabarcoding/optmodel15_Pred_1.tppl -m 'smc-apf' --resample align --subsample -n 1 --output optmodel15_Pred_1
 * Execution with 10000 particles and 1 sweep:
 * ./optmodel15_Pred_1 models/data/15samples/combined_samples.json 10000 5 > output/pred_1.json
 */

/*
 * Geometric dist. 
 */
function geometric(p: Real, n: Int): Int {
  assume a ~ Uniform(0.0, 1.0);
  if (a < p) {
    return n;
  }
  else {
    return geometric(p, addi(n, 1));
  }
}

/*
 * Recursive prediction function per species
 */   
function predict_species(dataset: Int[][], c_dist: Real[][], k_bio_dist: Real[], theta_dist: Real[], weights: Real[], p_values: Real[], n_spikeins: Int[], sample: Int, species: Int, n: Real[]): Real[] { 

  assume p_value ~ Gaussian(0.42, 0.05);

  //Sample index
  assume index_0 ~ Categorical(weights);
  let index = addi(index_0, 1);

  //Sample k and theta for this species
  let k_bio = k_bio_dist[index];
  let theta = theta_dist[index];

  //Predict n per sample
  let new_n = predict_sample(dataset, k_bio, theta, index, c_dist, p_value, n_spikeins, 1, species, n); 

  if eqi(species, length(dataset[1])) { // Are we done with all species?
    return new_n;
  }
  else { // If not, go to next one and start from sample 1 again.
    return predict_species(dataset, c_dist, k_bio_dist, theta_dist, weights, p_values, n_spikeins, 1, addi(species, 1), new_n); 
  }
}

/*
 * Recursive prediction function per sample
 */
function predict_sample(dataset: Int[][], k_bio: Real, theta: Real, index: Int, c_dist: Real[][], p_value: Real, n_spikeins: Int[], sample: Int, species: Int, n: Real[]): Real[] { 

  if neqi(dataset[sample][species], 0) { //If reads are not zero 

    //Sample c for this sample and index for the species
    let c = c_dist[sample][index];

    //1. 
    let sampled_n = Real(geometric(p_value, 1)); 
    //assume float_n ~ Exponential(p_value);
    //let sampled_n = Real(roundfi(float_n)); 
    
    //Observe species
    observe Real(dataset[sample][species]) ~ Gamma(sampled_n * k_bio, c * theta); 

    //join n's
    let new_n = join([n, [sampled_n]]);
    if eqi(sample, length(dataset)) { // Are we done with all samples?
      return new_n;
    }
    else { // If not, go to next sample
      return predict_sample(dataset, k_bio, theta, index, c_dist, p_value, n_spikeins, addi(sample, 1), species, new_n); 
    }
  }
  else { 
    if eqi(sample, length(dataset)) { // Are we done with all samples?
      return n;
    }
    else {
      return predict_sample(dataset, k_bio, theta, index, c_dist, p_value, n_spikeins, addi(sample, 1), species, n); 
    }
  }
}

/*
 * Model function
 * Data:
 *   Homogenate data, 15 samples. dataset is number of reads r per species per sample for two artificial spikeins
 * Priors: 
 *  Estimated p_values from ground truth count data per species
 * Posterior:
 *   returning n
 */
model function myModel(dataset: Int[][], c_dist: Real[][], weights: Real[], k_bio_dist: Real[], theta_dist: Real[], p_values: Real[], n_spikeins: Int[]) : Real[]  {

  //Go through species (here 1 to 472) and samples (here from 1 to 15)
  let n = predict_species(dataset, c_dist, k_bio_dist, theta_dist, weights, p_values, n_spikeins, 1, 1, []); 

  //Return predicted n
  return(n); 
}

