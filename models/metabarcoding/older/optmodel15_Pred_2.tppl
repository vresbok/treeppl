/*
 * File: optmodel15_Pred_2.tppl
 * Description: Probabilistic model taken from optimal metabarcoding adjusted to 15samples
 * Compilation:
 *  tpplc models/metabarcoding/optmodel15_Pred_2.tppl -m 'smc-apf' --resample align --subsample -n 1 --output optmodel15_Pred_2
 * Execution with 10000 particles and 1 sweep:
 * ./optmodel15_Pred_2 models/data/15samples/sampled_15s_combined.json 500 1 > test_pred_2.json
 */

/*
 * Geometric dist. 
 */
function geometric(p: Real, n: Int): Int {
  assume a ~ Uniform(0.0, 1.0);
  if (a < p) {
    return n;
  }
  else {
    return geometric(p, addi(n, 1));
  }
}

/*
 * Recursive prediction function per sample
 */  
function predict_sample(dataset: Int[][], c_dist: Real[][], k_bio_dist: Real[], theta_dist: Real[], weights: Real[], p_values: Real[], n_spikeins: Int[], sample: Int, species: Int, n: Real[]): Real[] { 
  //Sample c for this sample from dist
    assume c_index_1 ~ Categorical(weights);
    let c_index = addi(c_index_1,1);
    let c = c_dist[c_index][sample];
  //Predict n per species
  let new_n = predict_species(dataset, k_bio_dist, theta_dist, weights, c, p_values, n_spikeins, sample, species, n);
  if eqi(sample, length(dataset)) {
    return new_n;
  }
  else {
    return predict_sample(dataset, c_dist, k_bio_dist, theta_dist, weights, p_values, n_spikeins, addi(sample, 1), species, new_n); 
  }
}

/*
 * Recursive prediction function per species
 */
function predict_species(dataset: Int[][], k_bio_dist: Real[], theta_dist: Real[], weights: Real[], c: Real, p_values: Real[], n_spikeins: Int[], sample: Int, species: Int, n: Real[]): Real[] { 
  if neqi(dataset[sample][species], 0) { //If reads are not zero 
    
    assume index_1 ~ Categorical(weights);
    let index = addi(index_1, 1); // so index not zero
  
    let k_bio = k_bio_dist[index];
    let theta = theta_dist[index];
    //let c = c_dist[index][sample];
    
    //Sample n
    let sampled_n = Real(geometric(p_values[species], 1)); 

    //Observe species
    observe Real(dataset[sample][species]) ~ Gamma(sampled_n * k_bio, c * theta); 

    //join n's
    let new_n = join([n, [sampled_n]]);
    if eqi(species, length(dataset[1])) { 
      return new_n;
    }
    else {
      return predict_species(dataset, k_bio_dist, theta_dist, weights, c, p_values, n_spikeins, sample, addi(species, 1), new_n);
    }
  }
  else { 
    if eqi(species, length(dataset[1])) { 
      return n;
    }
    else {
      return predict_species(dataset, k_bio_dist, theta_dist, weights, c, p_values, n_spikeins, sample, addi(species, 1), n);
    }
  }
}

/*
 * Model function
 * Data:
 *   Homogenate data, 15 samples. dataset is number of reads r per species per sample for two artificial spikeins
 * Priors: 
 *  Estimated p_values from ground truth count data per species
 * Posterior:
 *   returning n
 */
model function myModel(dataset: Int[][], c_dist: Real[][], weights: Real[], k_bio_dist: Real[], theta_dist: Real[], p_values: Real[], n_spikeins: Int[]) : Real[]  {

  //Go through samples (here from 1 to 15), species (here 1 to 472).
  let n = predict_sample(dataset, c_dist, k_bio_dist, theta_dist, weights, p_values, n_spikeins, 1, 1, []); 

  return(n); 
}

